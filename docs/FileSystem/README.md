## Adding a task

When contracts on the blockchain need more computational power, they can use TrueBit to create computational tasks using method `addWithFile` in the TrueBit contract. There are three parameters:
* `init`: the Merkle root of the initialized code. Code initialization is described here:  https://github.com/TrueBitFoundation/ocaml-offchain/wiki/Initializing-and-preprocessing-WebAssembly
* `code_file`: this is the IPFS hash of the file that contains the task code.
* `input_file`: this is the id of a file stored in the blockchain. This file is the input to the task.

## Adding input files

The input file has to be registered with method `createFileWithContents(string name, uint nonce, bytes32[] arr, uint sz)`.
The parameters are as follows:
* `name`: name of the file.
* `nonce`: used to generate a unique identifier. It is just `keccak256(msg.sender, nonce)`.
* `arr`: contents of the file. Currently each element in the array will become one byte.
* `sz`: this will be the size in bytes, once the Merkle trees have been optimized.

## Registering Data

Assume we have a system that can be used to verified load data from IPFS to our tasks using the IPFS hashes.
For simplicity, we could have a function `getData(hash)` that returns an chunk of bytes when given an IPFS hash. There are two problems concerning data availability:
1. the task can just generate a hash of data that is only available for attacker
2. the task can generate a hash from data available to program, but when `getData` is called, the verifiers cannot know that (procedurally generate chunk)

One solution is that the IPFS data has to be registered. There are two possibilities
* the chunk or a chunk that contains the chunk has been registered as being available in the block chain (the standard case for data availability)
* the chunk has been registered with for example a command `putData(buffer)`, using verification game, it can be checked that this command has been ran before corresponding `getData` command

# FileSystem Design

Here is some pseudo-code about the filesystem. Something like this will be needed to be able to run wasm files generated by emscripten. There will probably be a standard way to access files in WebAssembly, so perhaps not everything should be implemented right away.

## IO block

The input and output blocks have to be in a format that can be easily read by smart contracts.
In the following, I assume that there are the following merkle roots:
* `names`: file names. There is a fixed maximum file name length, for example 1024
* `sizes`: sizes of the files
* `data`: data blocks with given size

The names and data require two level merkle proofs, so for example `data[2]` would be the Merkle root of file number `2`. 

## Instructions (seen as external calls in WASM)

There are three instructions for inputting data:
* `inputName(n, i)` returns the `i`th character in the name of the `n`th file.
* `inputSize(n)` returns the size of the `n`th file.
* `inputData(n, i)` returns the `i`th byte of the `n`th file.
There should be corresponding instructions for output.

## Inputting data from blockchain

For inputting data from blockchain, it is more efficient to not use Merkle roots, so there can be special data files, where there is a smart contract that maps a file number into file name and data.

For example we could have a contract address instead of the Merkle root of data of a file, and then this contract would map the file number to file data
```
contract FileMapper {
  function inputSize(uint32 n) returns uint64 {
    // Implementation here
  }
  function inputName(uint32 n, uint8 i) returns uint8;
  function inputData(uint32 n, uint64 i) returns uint8 {
    // can basically return any data from blockchain, but should be constant, otherwise the verification game won't work
  }
}
```

For example the input data could represent account balances of million addresses, and the task could be to calculate median.

How to make sure that the file contents won't change in the middle of verification game???

## Using Swarm or IPFS directly for the file system

Because Swarm and IPFS use Merkle roots, they can be used for verified computations, at least if data availability is guaranteed.

The instructions for using Swarm etc. hashes for file system directly would probably be a bit more complex, because they are larger than 64-bits. Otherwise they would hopefully be similar.

Chunks: instead of files, Swarm and IPFS store _chunks_. There are two kinds of chunks, leaf chunks and inner chunks. A leaf chunk contains a piece of data and its length. An inner chunk contains hashes of chunks and their total length.

In IPFS, files are chunks with names, and directories are chunks that have files or other directories as inner chunks.

In Swarm, there are instead JSON files that describe the directory structure.

## Simple file system

To implement the system calls, we have to implement them in a WASM file using the external calls that correspond to extra instructions. In practice it is easier to compile from C to WASM. Then this file can be linked with the file generated by emscripten, switching it to use our runtime.

For example we could have the following global structure to manage the filesystem:
```c
struct system {
  int next_fd;
  int ptr[1024]; // Pointers to the data blocks for each fd
  int pos[1024]; // Location inside the block
  char *file_name[1024];
  char *file_data[1024];
  int file_length[1024];
};

// Global variable that will store our system
system *sys;
```

Initializing the global structure:
```c
int getNameLength(int ptr) {
  int res = 0;
  while (inputName(ptr, res) != 0) res++;
  return res;
}

char *getName(int ptr) {
  int sz = getNameLength(ptr);
  char *res = malloc(sz+1);
  for (int i = 0; i < sz; i++) res[i] = inputName(ptr, i);
  res[sz] = 0;
  return res;
}

char *getData(int ptr) {
  int sz = inputSize(ptr);
  char *res = malloc(sz+1);
  for (int i = 0; i < sz; i++) res[i] = inputData(ptr+sz);
  return res;
}

void initSystem() {
  sys = malloc(sizeof(system));
  sys->nextfd = 3; // 0:stdin, 1:stdout, 2:stderr
  // Actually we should here have a list of file names?
  // Read input byte by byte, it includes file names and data
  int loc = 0;
  int index = 0;
  int nextLength = getNameLength(index);
  while (nextLength > 0) {
     sys->file_name[index] = getName(index);
     sys->file_size[index] = inputSize(index);
     sys->file_data[index] = getData(index);
     index++;
     nextLength = getNameLength(index);
  }
  sys->file_name[index] = null;
}
```

`___syscall5` is for opening files.

```c
int ___syscall5(int which, int *varargs) {
  char *name = varargs[0];
  int flags = varargs[1];
  int mode = varargs[2];
  // No empty names allowed
  if (!name || !name[0]) return -1;
  int index = 0;
  while (sys->file_name[index]) {
      if (strcmp(sys->file_name[index], name)) {
              int fd = sys->next_fd;
              sys->ptr[fd] = index;
              sys->loc[fd] = 0;
              sys->next_fd++;
              return fd;
      }
      index++;
  }
  // No such file
  return -1;
}
```



